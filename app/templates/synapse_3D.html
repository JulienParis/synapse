

<style>


	#canvas3D {
					/*color: #cccccc;*/
					font-family:Monospace;
					font-size:13px;
					text-align:center;
					margin: 0px;
					overflow: hidden;
	        color: #cccccc ;
	        background-color: {{ app_colors.three_background }} ;
				}
	div.dg.ac {
	  top : 8%
	}

	/*
	#info {
		position: absolute;
		top: 0px; width: 100%;
		padding: 5px;
	}

	a {
		color: #0080ff;
	}
	*/


</style>


<!-- cf : http://requirejs.org/docs/start.html -->
<!-- <script type="text/javascript" src="{{ url_for('static', filename='js/require.js') }}"></script> -->


<script type="text/javascript" src="{{ url_for('static', filename='js/three.js') }}"></script>
<!-- <script type="text/javascript" src="{{ url_for('static', filename='js/threejs/loaders/OBJLoader.js') }}"></script> -->
<!-- <script type="text/javascript" src="{{ url_for('static', filename='js/threejs/loaders/STLLoader.js') }}"></script> -->
<script type="text/javascript" src="{{ url_for('static', filename='js/threejs/Detector.js') }}"></script>
<script type="text/javascript" src="{{ url_for('static', filename='js/threejs/libs/dat.gui.min.js') }}"></script>
<script type="text/javascript" src="{{ url_for('static', filename='js/threejs/libs/stats.min.js') }}"></script>
<script type="text/javascript" src="{{ url_for('static', filename='js/threejs/controls/OrbitControls.js') }}"></script>
<script type="text/javascript" src="{{ url_for('static', filename='js/threejs/controls/PointerLockControls.js') }}"></script>
<!-- <script type="text/javascript" src="{{ url_for('static', filename='js/threejs/geometries/ConvexGeometry.js') }}"></script> -->
<script type="text/javascript" src="{{ url_for('static', filename='js/delaunay.js') }}"></script>



<div id="canvas3D">
</div>


<!-- vertex shader cf : https://www.clicktorelease.com/blog/vertex-displacement-noise-3d-webgl-glsl-three-js/ -->
<!-- cf too  : http://blog.2pha.com/experimenting-threejs-shaders-and-shadermaterial  -->
<!-- cf also :  https://github.com/Jam3/jam3-lesson-webgl-shader-threejs -->
<script type="x-shader/x-vertex" id="vertexshader_points">

	// --- PERLIN NOISE --- //
		// precision lowp float;
		// // uniform float u_time;     // temps écoulé depuis le lancement du shader
		//
		// // GLSL textureless classic 3D noise "cnoise",
		// // with an RSL-style periodic variant "pnoise".
		// // Author:  Stefan Gustavson (stefan.gustavson@liu.se)
		// // Version: 2011-10-11
		// //
		// // Many thanks to Ian McEwan of Ashima Arts for the
		// // ideas for permutation and gradient selection.
		// //
		// // Copyright (c) 2011 Stefan Gustavson. All rights reserved.
		// // Distributed under the MIT license. See LICENSE file.
		// // https://github.com/ashima/webgl-noise
		// //
		// vec3 mod289(vec3 x)  				{ return x - floor(x * (1.0 / 289.0)) * 289.0; }
		// vec4 mod289(vec4 x)  				{	return x - floor(x * (1.0 / 289.0)) * 289.0; }
		// vec4 permute(vec4 x) 				{	return mod289(((x*34.0)+1.0)*x); }
		// vec4 taylorInvSqrt(vec4 r) 	{ return 1.79284291400159 - 0.85373472095314 * r; }
		// vec3 fade(vec3 t) 					{ return t*t*t*(t*(t*6.0-15.0)+10.0); }
		//
		// // Classic Perlin noise
		// float cnoise(vec3 P)
		// {
		//   vec3 Pi0 = floor(P); // Integer part for indexing
		//   vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1
		//   Pi0 = mod289(Pi0);
		//   Pi1 = mod289(Pi1);
		//   vec3 Pf0 = fract(P); // Fractional part for interpolation
		//   vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0
		//   vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
		//   vec4 iy = vec4(Pi0.yy, Pi1.yy);
		//   vec4 iz0 = Pi0.zzzz;
		//   vec4 iz1 = Pi1.zzzz;
		//   vec4 ixy = permute(permute(ix) + iy);
		//   vec4 ixy0 = permute(ixy + iz0);
		//   vec4 ixy1 = permute(ixy + iz1);
		//   vec4 gx0 = ixy0 * (1.0 / 7.0);
		//   vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
		//   gx0 = fract(gx0);
		//   vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
		//   vec4 sz0 = step(gz0, vec4(0.0));
		//   gx0 -= sz0 * (step(0.0, gx0) - 0.5);
		//   gy0 -= sz0 * (step(0.0, gy0) - 0.5);
		//   vec4 gx1 = ixy1 * (1.0 / 7.0);
		//   vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
		//   gx1 = fract(gx1);
		//   vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
		//   vec4 sz1 = step(gz1, vec4(0.0));
		//   gx1 -= sz1 * (step(0.0, gx1) - 0.5);
		//   gy1 -= sz1 * (step(0.0, gy1) - 0.5);
		//   vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
		//   vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
		//   vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
		//   vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
		//   vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
		//   vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
		//   vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
		//   vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);
		//   vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
		//   g000 *= norm0.x;
		//   g010 *= norm0.y;
		//   g100 *= norm0.z;
		//   g110 *= norm0.w;
		//   vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
		//   g001 *= norm1.x;
		//   g011 *= norm1.y;
		//   g101 *= norm1.z;
		//   g111 *= norm1.w;
		//   float n000 = dot(g000, Pf0);
		//   float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
		//   float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
		//   float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
		//   float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
		//   float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
		//   float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
		//   float n111 = dot(g111, Pf1);
		//   vec3 fade_xyz = fade(Pf0);
		//   vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
		//   vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
		//   float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);
		//   return 2.2 * n_xyz;
		// }
		//
		// // Classic Perlin noise, periodic variant
		// float pnoise(vec3 P, vec3 rep)
		// {
		//   vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period
		//   vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period
		//   Pi0 = mod289(Pi0);
		//   Pi1 = mod289(Pi1);
		//   vec3 Pf0 = fract(P); // Fractional part for interpolation
		//   vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0
		//   vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
		//   vec4 iy = vec4(Pi0.yy, Pi1.yy);
		//   vec4 iz0 = Pi0.zzzz;
		//   vec4 iz1 = Pi1.zzzz;
		//   vec4 ixy = permute(permute(ix) + iy);
		//   vec4 ixy0 = permute(ixy + iz0);
		//   vec4 ixy1 = permute(ixy + iz1);
		//   vec4 gx0 = ixy0 * (1.0 / 7.0);
		//   vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
		//   gx0 = fract(gx0);
		//   vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
		//   vec4 sz0 = step(gz0, vec4(0.0));
		//   gx0 -= sz0 * (step(0.0, gx0) - 0.5);
		//   gy0 -= sz0 * (step(0.0, gy0) - 0.5);
		//   vec4 gx1 = ixy1 * (1.0 / 7.0);
		//   vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
		//   gx1 = fract(gx1);
		//   vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
		//   vec4 sz1 = step(gz1, vec4(0.0));
		//   gx1 -= sz1 * (step(0.0, gx1) - 0.5);
		//   gy1 -= sz1 * (step(0.0, gy1) - 0.5);
		//   vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
		//   vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
		//   vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
		//   vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
		//   vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
		//   vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
		//   vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
		//   vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);
		//   vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
		//   g000 *= norm0.x;
		//   g010 *= norm0.y;
		//   g100 *= norm0.z;
		//   g110 *= norm0.w;
		//   vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
		//   g001 *= norm1.x;
		//   g011 *= norm1.y;
		//   g101 *= norm1.z;
		//   g111 *= norm1.w;
		//   float n000 = dot(g000, Pf0);
		//   float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
		//   float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
		//   float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
		//   float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
		//   float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
		//   float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
		//   float n111 = dot(g111, Pf1);
		//   vec3 fade_xyz = fade(Pf0);
		//   vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
		//   vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
		//   float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);
		//   return 2.2 * n_xyz;
		// }
		// // Include the Ashima code for Perlin noise
		//
		// float turbulence( vec3 p ) {
		//   float w = 100.0;
		//   float t = -.5;
		//   for (float f = 1.0 ; f <= 10.0 ; f++ ){
		//     float power = pow( 2.0, f );
		//     t += abs( pnoise( vec3( power * p ), vec3( 10.0, 10.0, 10.0 ) ) / power );
		//   }
		//   return t;
		// }


	// Rotate / cf : https://gist.github.com/jeanlescure/e27c93b73a10b64e85e4
	uniform float rotationX ;
	uniform float rotationY ;
	uniform float rotationZ ;
	// uniform vec3  limitsXYZ ;

	// rotation matrice function
	mat4 rotMat ( float rotationX, float rotationY, float rotationZ ) {

		mat4 rXPos = mat4(vec4(1.0,0.0,0.0,0.0),
											vec4(0.0,cos(rotationX),-sin(rotationX),0.0),
											vec4(0.0,sin(rotationX),cos(rotationX),0.0),
											vec4(0.0,0.0,0.0,1.0)
										);

		mat4 rYPos = mat4(vec4(cos(rotationY),0.0,sin(rotationY),0.0),
											vec4(0.0,1.0,0.0,0.0),
											vec4(-sin(rotationY),0.0,cos(rotationY),0.0),
											vec4(0.0,0.0,0.0,1.0)
										);

		mat4 rZPos = mat4(vec4(cos(rotationZ),-sin(rotationZ),0.0,0.0),
											vec4(sin(rotationZ),cos(rotationZ),0.0,0.0),
											vec4(0.0,0.0,1.0,0.0),
											vec4(0.0,0.0,0.0,1.0)
										);

		mat4  vPosition ;
		vPosition =  rXPos * rZPos * rYPos ;

		return vPosition ;

	}


	uniform   float time      ;
	uniform   float velFactor ;
	uniform   float scaFactor ;
	uniform   float breathing ;
	uniform   float size      ;
	uniform   float familyI   ;
	uniform   float familiesL ;
	uniform   float groupI    ;
	uniform   float groupL    ;

	// attribute vec3  customColor;
	// attribute float customFrequency;
	// attribute vec3  customVelocity;


	// varying   vec3  vColor;
	// varying   vec4  famillyC ;

	// --- CUSTOM NOISE --- cf : https://stackoverflow.com/questions/15628039/simplex-noise-shader
		// hash based 3d value noise
		// function taken from https://www.shadertoy.com/view/XslGRr
		// Created by inigo quilez - iq/2013
		// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.

		// ported from GLSL to HLSL

		// float hash( float n )
		// {
		// 		return frac(sin(n)*43758.5453);
		// }
		//
		// float noise( float3 x )
		// {
		// 		// The noise function returns a value in the range -1.0f -> 1.0f
		//
		// 		float3 p = floor(x);
		// 		float3 f = frac(x);
		//
		// 		f       = f*f*(3.0-2.0*f);
		// 		float n = p.x + p.y*57.0 + 113.0*p.z;
		//
		// 		return lerp(lerp(lerp( hash(n+0.0), hash(n+1.0),f.x),
		// 									 lerp( hash(n+57.0), hash(n+58.0),f.x),f.y),
		// 							 lerp(lerp( hash(n+113.0), hash(n+114.0),f.x),
		// 									 lerp( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);
		// }


	// GENERIC NOISE --- cf : https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83

	float mod289( float x ){ return x - floor(x * (1.0 / 289.0)) * 289.0; }
	vec4  mod289( vec4  x ){ return x - floor(x * (1.0 / 289.0)) * 289.0; }
	vec4  perm(   vec4  x ){ return mod289(((x * 34.0) + 1.0) * x); }

	float noise(vec3 p){
	    vec3 a = floor(p);
	    vec3 d = p - a;
	    d = d * d * (3.0 - 2.0 * d);

	    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);
	    vec4 k1 = perm(b.xyxy);
	    vec4 k2 = perm(k1.xyxy + b.zzww);

	    vec4 c = k2 + a.zzzz;
	    vec4 k3 = perm(c);
	    vec4 k4 = perm(c + 1.0);

	    vec4 o1 = fract(k3 * (1.0 / 50.0));
	    vec4 o2 = fract(k4 * (1.0 / 50.0));

	    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);
	    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);

	    return o4.y * d.y + o4.x * (1.0 - d.y) ;
	}



	void main() {

		// vColor = customColor;
		// familyC = familyI * .1 ;
		// familyC = vec4 ( familyI, familyI, familyI, .5 );
		// familyC = vec4 ( vec3( 1., familyI , 1. ) , .5 );

		// update position from within vertex shader
		// cf : https://fr.wikipedia.org/wiki/Signal_sinusoïdal
		// cf : https://stackoverflow.com/questions/1073606/is-there-a-one-line-function-that-generates-a-triangle-wave

		// float vnoise = float( sin( time * velFactor * customFrequency ) ) ;
		float vnoise   = noise( position + time * velFactor * familyI ) ;

		vec3 posNormal =  10. * normalize( position ) * vnoise * scaFactor * ( .0 +  float( sin(time) ) *  breathing ) ;

		// float newPosX = position.x + posNormal.x * scale * 10. ; // * .02 ; // float( limitsXYZ.x/2. * sin( time * customVelocity.x * velFactor + position.x  ) ) ;
		// float newPosY = position.y + posNormal.y * scale * 10. ; // * .02 ; // float( limitsXYZ.y/2. * sin( time * customVelocity.y * velFactor + position.y  ) ) ;
		// float newPosZ = position.z + posNormal.z * scale * 10. ; // * .02 ;

		// float newPosZ = float( limitsXYZ.z/2. * sin( time * customVelocity.z * velFactor + position.z  ) ) ;

		// store updated position
		// vec3 newPos  = vec3( newPosX, newPosY, newPosZ ) ;

		vec3 newPos_  = position + posNormal ;
		vec4 newPos   = vec4( newPos_ , 1.0 ) ;

		mat4 rotP = rotMat( time * .1  * velFactor , sin(time*.1) , time * velFactor ) ;

		// apply position to view matrix
		vec4 mvPosition =  modelViewMatrix * rotP * newPos ; // new position
		// vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 ); // original position




		// gl_PointSize    = size * ( 400.0 / -mvPosition.z ) ;
		gl_PointSize = ( 1.0 + sin( time )) * size * ( 300.0 / length( mvPosition.xyz ) );
		// gl_PointSize    = size + size * ( sin( time ) );

		// apply projection matrix to viewPosition
		gl_Position  = projectionMatrix * mvPosition ;



	}

</script>


<script type="x-shader/x-fragment" id="fragmentshader_points">

	uniform   vec2 resolution;

	uniform vec3      color;
	uniform sampler2D texture;
	varying vec3   vColor;

	void main() {
		gl_FragColor = vec4( color * vColor, 1. );
		gl_FragColor = gl_FragColor * texture2D( texture, gl_PointCoord );
	}

</script>




<!--  tests shaders  -->
<script type="x-shader/x-vertex" id="vertexShader">
	// attribute vec3 center;
	// varying vec3 vCenter;
	void main() {
		// vCenter = center;
		gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
	}
</script>

<script type="x-shader/x-fragment" id="fragmentShader">

	uniform   float familyI   ;
	uniform   float familiesL ;
	uniform   float groupI    ;
	uniform   float groupL    ;
	// varying vec4 familyC  ;
	uniform float time ;
	// uniform vec3 color ;
	// uniform vec4 color ;

	void main() {
		// gl_FragColor = vec4( familyI  , 0. , 0.  , 1. );
		vec3 color = vec3 ( sin(time * familyI / familiesL ), 1., 1. );
		gl_FragColor = vec4( color , .8 );
		// gl_FragColor = color ;
		// gl_FragColor = familyC ;
		// gl_FragColor.rgb = mix( vec3( famillyI * .2 ), vec3( famillyI * .1 ), vec3( 1. ) );
		// gl_FragColor.rgb = mix( vec3( 1. - famillyI * .1  ), vec3( 1. - famillyI * .1 ), vec3(  1. - famillyI * .1 ) );
		// gl_FragColor.a = 1.0;
	}
</script>


<script>


	// --- GLOBAL VARIABLES --- //
	// ------------------------ //

		var start = Date.now() ;

		var group, groupH ;
		var container, controls, stats ;
		var particlesData = [] ;
		var camera, scene, renderer ;
		var gui ;

		var raycaster, intersects ;
		var mouse, INTERSECTED ;

		var WIDTH  = window.innerWidth;
		var HEIGHT = window.innerHeight;


		var pPositions, pSizes, pColors, pFrequencies, pVelocities ;
		var particlesGeom ;
		var pointCloud, convexHullMesh ;

		var positionsL, colorsL ;
		// var linesMesh ;
		// var meshesList = [] ;
		// var sphereMesh ;

		var maxParticleCount 	= 1000;
		var particleCount    	= 0;
		var Rbasis     				= 100.;
		var RmarginAngle   		= 0.4 ;
		var RmarginDist   		= Rbasis / 10. ;
		var RbasisHalf 	   		= RmarginAngle / 2.;
		var maxCircleRad ;

		// var velocityFactor = 1. ;
		// var scaleFactor    = 1. ;

		var effectController = {
			showGroup        : true,
			showHelper       : true,
			// minDistance     : 120,
			// limitConnections: true,
			// maxConnections  : 10,
			// particleCount   : particleCount,
			velocityFactor  : .2 ,
			scaleFactor     : .4 ,
			breathing       : 1. ,
			rotationGroup   : 1. ,
		};

		var familiesColors = [
			"rgb(255,188,158)",
			"rgb(79,116,255)",
			"rgb(213,209,0)",
			"rgb(201,52,72)",
			"rgb(156,255,168)",
			"rgb(255,133,16)",
			"rgb(1,136,116)",
		];




	// --- GEOMETRICAL FUNCTIONS --- //

	// random number within interval
	function getRandomNumber(min, max) {
	    return Math.random() * (max - min) + min;
	} ;

	// function rand() {
		// 	var x = Math.random() ;
		// 	return x ;
		// };

	// randomly create vertex position on a sphere arc
	// function positionVertexOnSphere(radius, phiStart, phiEnd, thetaStart, thetaEnd) {
		//
		// 	var position = new THREE.Vector3();
		//
		// 	var phi   = getRandomNumber(phiStart  , phiEnd)   ;
		// 	var theta = getRandomNumber(thetaStart, thetaEnd) ;
		//
		// 	position.x = radius * Math.sin(phi) * Math.cos(theta) ;
		// 	position.y = radius * Math.sin(phi) * Math.sin(theta) ;
		// 	position.z = radius * Math.cos(phi) ;
		//
		// 	console.log(">>> position V / phiStart / phi / theta", position, phiStart, phi, theta );
		//
		// 	return position ;
		// } ;


	// randomly create vertex position on a sphere arc
	// cf : http://mathinsight.org/spherical_coordinates
	function positionVertexOnProjectedCircleOntoSphere( radiusCircleMax, radiusSphere ) {

		var position = new THREE.Vector3();

		// populate circle with random point
		var te = getRandomNumber( 0, 2. * Math.PI ) ;
		var ra = getRandomNumber( radiusCircleMax/2., radiusCircleMax ) ;
		position.x = ra * Math.cos(te) ;
		position.y = ra * Math.sin(te) ;

		// populate rectangle with random point
		// position.x = getRandomNumber( -radiusCircleMax*1.0, radiusCircleMax*1.0 );
		// position.y = getRandomNumber( -radiusCircleMax*0.6, radiusCircleMax*0.6 );

		lenXY = Math.sqrt( Math.pow(position.x, 2) + Math.pow(position.y, 2)  ) ;
		position.z = Math.sqrt( Math.pow(radiusSphere, 2) - Math.pow(lenXY, 2)  ) ;

		return position ;

	};


	// max radius for every plane circle
	function maxCircleRadius ( familiesLength ) {
		var angleIsocele = ( Math.PI * 2. - ( familiesLength * RmarginAngle ) ) / familiesLength  ;
		console.log("___ angleIsocele : ", angleIsocele);
		var maxRadius    = Rbasis * Math.sin( angleIsocele ) * 0.8 ;
		return maxRadius ;
	};

	// for rotation whole family on Y axis
	function familyAngle( familyIndex, familiesLength ) {
		// var angleFa = Math.PI * 2 * familyIndex / familiesLength ;
		var angleFa = ( Math.PI * 2. - ( familiesLength * RmarginAngle ) ) / familiesLength ;
		angleFa += RmarginAngle ;
		angleFa *= familyIndex  ;
		return angleFa ;
	};

	// for rotation whole group on X axis
	function groupAngle( groupIndex, groupsLength, angleLap ) {
		// var angleGr = 1. * ( Math.PI / groupsLength ) ;
		// if ( groupIndex % 2 ) {
		// 	angleGr  *= - groupIndex ;
		// } else {
		// 	angleGr  *= groupIndex ;
		// }
		var angleGr = ( groupIndex - groupsLength/2. ) * Math.PI / angleLap ;
		// if ( groupIndex % 2 ) {
		// 	angleGr  *= - 1 ;
		// }
		return angleGr ;
	};

	// for radius orginal cluster's circle
	function groupRadius( groupsLength ) {
		var absMargin   = Rbasis - Math.cos(RmarginAngle) ;
		var sphereDiam  = Rbasis * 2. -  2. * absMargin ;
		var clusterDiam = sphereDiam / groupsLength - ( absMargin * groupsLength - 1 ) ;
		var clusterRad  = clusterDiam / 2.    ;

		if (clusterRad > maxCircleRad)  {
			clusterRad = maxCircleRad ;
		};

		return clusterRad ;
	};

	// for distance origin to cluster
	function sphereRadius( clusterIndex, margin ) {
		var clusterDist = Rbasis + clusterIndex * margin * 1.4 ;
		return clusterDist ;
	};



	// --- DEFINE SHADER MATERIALS : SHADERMATERIAL AND USUAL MATERIAL
	function createShaderMaterial ( familyIndex,
																	familiesLength,
																	groupIndex,
																	groupsLen,
																	is_wire,
																	is_texture ) {

		var colorG  = new THREE.Color( 0xffffff ) ;
		// var randColor = Math.random() ;
		// var famColor = familyIndex / familiesLength ;
		// // var randHSl = "hsl(" + randColor + ", 100%, 80%)" ;
		// var colorG  = new THREE.Color( famColor, 0.2,  0.6 ) ;

		var famColor = familiesColors[familyIndex] ;
		// var colorG  = new THREE.Color( famColor )  ;


		console.log( ">>> familyIndex" , familyIndex );

		var uniforms = {
			time        : { type  : "f"  , value: 1.0 },
			resolution  : { type  : "v2" , value: new THREE.Vector2() },
			velFactor   : { value : effectController.velocityFactor },
			scaFactor   : { value : effectController.scaleFactor },
			breathing   : { value : effectController.breathing },
			color       : { value : colorG },
			familyI     : { value : familyIndex },
			familiesL   : { value : familiesLength },
			groupI      : { value : groupIndex  },
			groupsL     : { value : groupsLen  },
		} ;

		if ( is_wire == false ) {
			uniforms.size = { value : 50. } ;
		} ;

		if ( is_texture == true ) {
			uniforms.texture = { value: new THREE.TextureLoader().load( "{{ url_for('static', filename='textures/sprites/spark1.png') }}" ) } ;
		} ;

		// from : https://github.com/mrdoob/three.js/blob/master/examples/webgl_custom_attributes_points.html
		var material_shader = new THREE.ShaderMaterial( {
			uniforms      : uniforms ,
			vertexShader  : document.getElementById( 'vertexshader_points'   ).textContent,
			fragmentShader: document.getElementById( 'fragmentshader_points' ).textContent,
			// transparent:    true,
			// wireframe  :    true
		});

		if ( is_wire == true ) {
			material_shader.fragmentShader = document.getElementById( 'fragmentShader' ).textContent ;
			material_shader.transparent    = true ;
			material_shader.wireframe      = true ;
		} ;

		return material_shader ;

	};


	//// --- DEFINE BASIC LINES MATERIAL
	var materialLines = new THREE.LineBasicMaterial( {
		vertexColors: THREE.VertexColors,
		blending    : THREE.AdditiveBlending,
		transparent : true
	} );

	var wireframeMaterial = new THREE.MeshBasicMaterial( {
		color      : 0xffffff,
		wireframe  : true,
		// transparent: true
	} );



	// -------------------------------------------------------
	// SET PARTICLES SYSTEM
	function addPointsCloud(particlesLength, angleFamily, angleGroup, radiusGroup, radiusCluster, wireORpoints) {

		// empty arrays variables
			pPositions   = new Float32Array( particlesLength * 3 );
			pColors      = new Float32Array( particlesLength * 3 );
			pSizes       = new Float32Array( particlesLength     );
			// pFamily      = new Float32Array( particlesLength     ); // those are uniforms --> set in ShaderMaterial
			// pGroup       = new Float32Array( particlesLength     ); // those are uniforms --> set in ShaderMaterial
			// pFrequencies = new Float32Array( particlesLength     );
			// pVelocities  = new Float32Array( particlesLength * 3 );

			var color     = new THREE.Color( 0xffffff );
			var vertices3 = [] ;
			var vertices2 = [] ;


			// sphere arc variables
			// var radiusCircle 				= Rbasis*2/3 ;
			// var radiusSphere 				= Rbasis ;
			// var phiStart 			= 1.2 ;
			// var phiLength 		= Math.PI - ( phiStart ) ;
			// var thetaStart 		= 2. ;
			// var thetaLength 	= ( Math.PI * 2 ) - ( thetaStart ) ;
			// console.log("sphere variables : radius / thetaLength / phiLength ",radius, thetaLength, phiLength  );


		// CREATE EACH PARTICLE
		for ( var i = 0; i < particlesLength; i++ ) {


			// var vertex3 = positionVertexOnSphere(radius, phiStart, phiLength, thetaStart, thetaLength) ;
			// var vertex3 = positionVertexOnProjectedCircleOntoSphere(radiusCircle, radiusSphere) ;
			var vertex3 = positionVertexOnProjectedCircleOntoSphere(radiusGroup, radiusCluster) ;

			// var vertex3 = new THREE.Vector3();
			var vertex2 = new Vertex();

			vertex2.x = vertex3.x ;
			vertex2.y = vertex3.y ;

			// vertex2.x = vertex3.x = Math.random() * Rbasis - Rbasis / 2.;
			// vertex2.y = vertex3.y = Math.random() * Rbasis - Rbasis / 2.;
			// vertex3.z = 0 ; // Math.random() * Rbasis - Rbasis / 2.;


			vertex3.toArray( pPositions, i * 3 );
			vertices3[i] = vertex3 ;
			vertices2.push( vertex2 )  ;

			// set color cf : https://www.w3schools.com/colors/colors_hsl.asp
			color.setHSL( 0., 0., 1. );
			color.toArray( pColors, i * 3 );

			// push to separate particlesData
			// particlesData.push( {
				// velocity: new THREE.Vector3( -1 + Math.random() , -1 + Math.random(),  -1 + Math.random() ),
				// rotPhi : , // in radians
				// rotThe : , // in radians
				// numConnections: 0
			// } );

			// set default size and frequency

			pSizes[i]       = 100 ;
			// pFrequencies[i] = 5 * Math.random() + 0.5;
			// velocity        = new THREE.Vector3( -1 + Math.random() , -1 + Math.random(),  -1 + Math.random() ),
			// velocity.toArray( pVelocities, i * 3 );

		}


		// console.log("--- pPositions : ", pPositions);
		// console.log("--- vertices2 : ",  vertices2);
		// console.log("--- vertices3 : ",  vertices3);


		var geomTri_buffer = new THREE.BufferGeometry();
		geomTri_buffer.addAttribute( 'position',        new THREE.BufferAttribute( pPositions,   3 ).setDynamic( true ) );


		if ( wireORpoints == "points" ) {
		// --- ADDING POINTS --- //
			// -----------------------------------------------------------------------
			// console.log(pPositions);
			// var geomTri_buffer = new THREE.BufferGeometry();
			// geomTri_buffer.setDrawRange( 0, particleCount );
			// geomTri_buffer.addAttribute( 'position',        new THREE.BufferAttribute( pPositions,   3 ).setDynamic( true ) );
			geomTri_buffer.addAttribute( 'customColor',     new THREE.BufferAttribute( pColors,      3 ) ); //.setDynamic( true ) );
			geomTri_buffer.addAttribute( 'size',            new THREE.BufferAttribute( pSizes,       1 ) ); //.setDynamic( true ) );
			// geomTri_buffer.addAttribute( 'customFrequency', new THREE.BufferAttribute( pFrequencies, 1 ) ); //.setDynamic( true ) );
			// geomTri_buffer.addAttribute( 'customVelocity',  new THREE.BufferAttribute( pVelocities,  3 ) ); //.setDynamic( true ) );
			//
			// // create the particle system with material
			// var materialPoints_shader_custom = createShaderMaterial_points( r,r,r/10, true ) ;
			//
			// console.log("--- materialPoints_shader_custom : ", materialPoints_shader_custom);
			// pointCloud = new THREE.Points( geomTri_buffer, materialPoints_shader_custom );
			//
			// group.add( pointCloud );
		}


		else {
		// --- ADDING TRIANGULATED MESH --- //
			// -----------------------------------------------------------------------
			// TRYING DELAUNAY TRIANGULATION ON VERTICES 2D (projectd on plane XY)
			// cf : https://github.com/callumprentice/callumprentice.github.io/blob/master/apps/delaunay/index.html
			// cf didn't tried it but seems nice : https://github.com/mapbox/delaunator

			var triangles = triangulate(vertices2);
			// console.log("--- triangles : ", triangles);

			var geomTri = new THREE.Geometry();
			var f = 0;

			// topology custom to recreate indexed BufferGeometry
			// cf : https://stackoverflow.com/questions/36730365/how-can-i-add-faces-to-an-indexed-three-buffergeometry
			var uniq_edges_set = new Set() ;
			var facesVIndices  = [] ;

			triangles.forEach( function(tri) {

				// get v1, v2, v3 indices
				var v0_i = vertices2.indexOf(tri.v0);
				var v1_i = vertices2.indexOf(tri.v1);
				var v2_i = vertices2.indexOf(tri.v2);

				// store indices
				facesVIndices.push(v0_i) ;
				facesVIndices.push(v1_i) ;
				facesVIndices.push(v2_i) ;

				// make and store edges vindices

				var e0_   = [v0_i,v1_i].sort() ; var e0 = e0_.join(".") ;
				var e1_   = [v1_i,v2_i].sort() ; var e1 = e1_.join(".") ;
				var e2_   = [v2_i,v0_i].sort() ; var e2 = e2_.join(".") ;

				// add edges to unique edges set
				uniq_edges_set.add(e0).add(e1).add(e2) ;


			})

			// console.log("--- uniq_edges_set : ", uniq_edges_set);
			// make list of edges as couples of vertex indices
			var uniq_edges_v_indices   = [] ;
			for (let eString of uniq_edges_set) {
				var vi_s = eString.split(".") ;
				var vi_0 = parseInt(vi_s[0]) ;
				var vi_1 = parseInt(vi_s[1]) ;
				uniq_edges_v_indices.push(vi_0) ;
				uniq_edges_v_indices.push(vi_1) ;
			};
			// console.log("--- uniq_edges_v_indices : ", uniq_edges_v_indices);

			// var geomTri_buffer = new THREE.BufferGeometry();//.fromGeometry(geomTri) ;
				// var ePositions = new Float32Array( geomTri.vertices.length * 3 );
				// for (i = 0; i < geomTri_buffer.attributes.position.length ; i++){
				// 	var eV = geomTri_buffer.attributes.position[i] ;
				// 	if(i==0) {
				// 		console.log("--- eV --- ", eV);
				// 	}
				// 	eV.toArray( ePositions, i * 3 );
				// };
				// console.log("--- ePositions :", ePositions );
				// geomTri_buffer.setDrawRange( 0, 17984  );
			// geomTri_buffer.addAttribute( 'position',        new THREE.BufferAttribute( pPositions,     3 ).setDynamic( true ) );
			geomTri_buffer.setIndex(      new THREE.BufferAttribute( new Uint16Array ( facesVIndices , 1) ) );
			// geomTri_buffer.addAttribute( 'customFrequency', new THREE.BufferAttribute( pFrequencies,   1 ) ); //.setDynamic( true ) );
			// geomTri_buffer.addAttribute( 'customVelocity',  new THREE.BufferAttribute( pVelocities,    3 ) ); //.setDynamic( true ) );
		}

		// console.log("--- geomTri_buffer : ", geomTri_buffer);

		return geomTri_buffer ;


	};





  $(document).ready(function(){

    // --- FAKE LIGHT JSON NOTICES
		var json_fake = {
			"ART": {	"CODE": "A",
								"STATS": 14082,
								"CHILDREN": [
															{	"NOTICES": [ {"id_o": "1431521"}, {"id_o": "1444227"}, {"id_o": "0180420"} ],
																"CODE": "A.1",
																"STATS": 1420,
																"NAME": "GRAPHISME"
															},
															{	"NOTICES": [ {"id_o": "1235563"}, {"id_o": "0982809"}, {"id_o": "0982806"} ],
																"CODE": "A.2",
																"STATS": 2408,
																"NAME": "LOISIRS CREATIFS"
															}
														]
							},

			"JEU": {	"CODE": "J",
								"STATS": 7102,
								"CHILDREN": [
															{	"NOTICES": [ {"id_o": "1181008"}, {"id_o": "1181016"} ],
																"CODE": "J.0",
																"STATS": 3524,
																"NAME": "JEUX A REGLES"
															},
															{	"NOTICES": [ {"id_o": "1267718"}, {"id_o": "1267716"}, {"id_o": "1115620"} ],
																"CODE": "J.1",
																"STATS": 808,
																"NAME": "JEUX D'ASSEMBLAGE"
															}
														]
							},


			};

		// --- LOAD JSON NOTICES AS CALLBACK
    function preload_notices(callback){
      $.getJSON( "{{ url_for('static', filename='data/JSON_notices_nested.json') }}", function( json ) {
        console.log("... JSON_notices_nested loaded with getJSON");
        callback(json);
      }
    )};

		// --- START 3D RENDERING AFTER CALLBACK
		preload_notices(function(json) {

			//Use your data here
			console.log("... JSON_notices_nested after callback");
			var json_notices = json ;
			console.log( json_notices );



			init();

			initGUI();

			animate();
			// render() ;


			// GUI controls
			// check : http://learningthreejs.com/blog/2011/08/14/dat-gui-simple-ui-for-demos/
			// check also : https://workshop.chromeexperiments.com/examples/gui/#1--Basic-Usage
			function initGUI( ) {

				gui = new dat.GUI();

				var f1 = gui.addFolder("Display") ;
					f1.add( effectController, "showGroup"  ).onChange( function( value ) {  group.visible   = value; } );
					f1.add( effectController, "showHelper" ).onChange( function( value ) {  groupH.visible  = value; } );

				var f2 = gui.addFolder("factors");
					// f2.add( effectController, "minDistance"   ,  10, 300 , 1       );
					f2.add( effectController, "velocityFactor",  0.,  2.  , 0.01   ); // .onChange( onChangeControl(scene, "velFactor") ) ;
					f2.add( effectController, "scaleFactor",     0.,  10. , 0.1    ); // .onChange( onChangeControl(scene, "scaFactor") ) ;
					f2.add( effectController, "breathing"  ,     0.,  1.  , 0.1    ); // .onChange( onChangeControl(scene, "breathing") ) ;
					f2.open() ;

				var f3 = gui.addFolder("limits");
					f3.add( effectController, "rotationGroup",  0.,  1., 0.1 );
					f3.open() ;

				console.log("--- initGUI / gui :", gui);

			};





			// INIT FUNCTION
      function init() {

				// --- BASIC STUFF --- //
	  			container = document.getElementById( 'canvas3D' );


	      	// set scene
	  			camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 10, 5000 );
	  			camera.position.x = 200;
					camera.position.y = 300;
					camera.position.z = 100;

	  			scene = new THREE.Scene();
	        scene.fog = new THREE.FogExp2( 0xffffff, 0.002 );

	        group = new THREE.Group();
	  			scene.add( group );

					groupH = new THREE.Group();
					scene.add( groupH ) ;
	        var helper = new THREE.BoxHelper( new THREE.Mesh( new THREE.BoxGeometry( Rbasis, Rbasis, Rbasis ) ) );
						helper.name = "helper" ;
		  			helper.material.color.setHex( 0x080808 );
		  			helper.material.blending = THREE.AdditiveBlending;
		  			helper.material.transparent = true;
		  			groupH.add( helper );




				// console.log("--- meshesList", meshesList );




				// -----------------------------
				// test iteration on fake JSON
				var maxCluster = 1000 ;
				// iteration on families
				// for (var family in json_fake ){
				// 	console.log( "--- ITERATION FOR / JSON : ", family, json_fake[family] );
				// 	// iteration on groups
				// } ;

				var familiesLen = Object.keys(json_notices).length ;
				console.log("--- ");
				console.log("--- familiesLength", familiesLen);
				maxCircleRad = maxCircleRadius ( familiesLen ) ;
				console.log("--- maxCircleRad", maxCircleRad);


				// iteration on families
				Object.keys(json_notices).forEach( function (keyFa, indexFa) {

					// -- FOR EACH FAMILY
					console.log("--- ITERATION FA / keyFa, indexFa : ", keyFa, indexFa );

					var angleFa = familyAngle( indexFa, familiesLen);
					console.log("--- ITERATION FA / angleFa : ", angleFa );

					var faGroups     = json_notices[keyFa]["CHILDREN"];
					var faGroupsLen  = Object.keys(faGroups).length   ;
					console.log("--- ITERATION FA / keyFa, faGroupsLen : " , keyFa, faGroupsLen );


					Object.keys(faGroups).forEach( function (keyGroup, indexGroup) {

						// --- FOR EACH FAMILY
						var groupName = faGroups[keyGroup]["NAME"]  ;
						var groupLen  = faGroups[keyGroup]["STATS"] ;

						var groupFa3D = new THREE.Group () ;
						groupFa3D.customFactor = getRandomNumber( 1, 5);
						scene.add( groupFa3D );

						console.log("------ ITERATION GR / keyFa, keyGroup, groupName, groupLen : " , keyFa, keyGroup, groupName, groupLen );
						var distGroup  = sphereRadius(indexGroup, RmarginDist  ) ;
						var angleGroup = groupAngle(  indexGroup, faGroupsLen, 5. );

						// Object.keys(faGroups).forEach( function (keyGroup, indexGroup) {

						// addPointsCloud -->          particlesLength, angleFamily, angleGroup, radiusGroup,     radiusCluster
						var geomTri_buffer = addPointsCloud(maxCluster, angleFa,     angleGroup, maxCircleRad*.8, Rbasis*1.,     "wire") ; // distGroup or Rbasis

						var materialLines_shader_custom = createShaderMaterial (
																																		indexFa,
																																		familiesLen,
																																		indexGroup,
																																		faGroupsLen,
																																		is_wire = true,
																																		is_texture = false
																																	) ;

						// console.log("--- materialLines_shader_custom : ",materialLines_shader_custom);
						// linesMesh = new THREE.LineSegments( geomTri_buffer, materialLines_shader_custom) ;
						var linesMesh = new THREE.LineSegments( geomTri_buffer, materialLines_shader_custom) ;
						// meshesList.push(linesMesh) ;

						// linesMesh = new THREE.LineSegments( geomTri_buffer, wireframeMaterial) ;

						// linesMesh = new THREE.Mesh( geomTri, wireframeMaterial) ;
						// console.log( "--- linesMesh : ", linesMesh );


						// apply rotation on sub-group
						// var rot = new THREE.Euler( angleGroup, angleFa, 0, 'XYZ' );
						// linesMesh.position.applyEuler(rot) ;

						// linesMesh.eulerOrder = "ZYX" ;
						linesMesh.rotation.order = "ZYX" ;
						linesMesh.rotation.y += angleFa ;
						linesMesh.rotation.x += angleGroup ;



						groupFa3D.add( linesMesh );



					});


					console.log(" ======================================== ");



				}) ;










				// --- RENDERING --- //
	        // RENDERER
	  			renderer = new THREE.WebGLRenderer( { antialias: true, alpha : true } ); // alpha true for css background-color
	  			renderer.setPixelRatio( window.devicePixelRatio );
	  			renderer.setSize( WIDTH, HEIGHT );
	  			renderer.gammaInput  = true;
	  			renderer.gammaOutput = true;
	  			container.appendChild( renderer.domElement );



					// CONTROLS
	        controls = new THREE.OrbitControls( camera, container );
	        // controls = new THREE.TrackballControls( camera, container );
					// cf : https://github.com/mrdoob/three.js/blob/master/examples/misc_controls_pointerlock.html
	  			controls.minDistance   = 1. ;
	  			controls.maxDistance   = 1000.;
	  			controls.dampingFactor = 0.   ;

	        // set stats box
	  			// stats = new Stats();
	  			// container.appendChild( stats.dom );


	        // raycasting for mouse interaction
					raycaster = new THREE.Raycaster();
					mouse     = new THREE.Vector2();

					// onWindowResize();
	        window.addEventListener(   'resize',    onWindowResize,      false );
	        document.addEventListener( 'mousemove', onDocumentMouseMove, false );

					//

      }


			// UI FUNCTIONS
      function onDocumentMouseMove( event ) {
				event.preventDefault();
				mouse.x =   ( event.clientX / WIDTH )  * 2 - 1;
				mouse.y = - ( event.clientY / HEIGHT ) * 2 + 1;
			};

      // function onWindowResize() {
			// 	renderer.setSize( WIDTH, HEIGHT );
  		// 	camera.aspect = WIDTH / HEIGHT ;
  		// 	camera.updateProjectionMatrix();
  		// };

			// RESIZE FUNCTION
			function onWindowResize() {
				WIDTH = window.innerWidth ;
				HEIGHT = window.innerHeight ;
				camera.aspect = WIDTH / HEIGHT ;
				camera.updateProjectionMatrix();
				renderer.setSize( WIDTH, HEIGHT );
			};


			// --- TRAVERSE SCENE FUNCTIONS --- //
			function onChangeControl ( factorName ) {

				scene.traverse( function( node ) {

					if ( node instanceof THREE.LineSegments | node instanceof THREE.Points ) {

						if (node.name != "helper") {
							// console.log("--- traverse / node : ", node );

							if ( factorName == "velFactor" ) {
								node.material.uniforms.velFactor.value  = effectController.velocityFactor ;
							}
							if ( factorName == "scaFactor" ) {
								node.material.uniforms.scaFactor.value  = effectController.scaleFactor ;
							}
							if ( factorName == "breathing" ) {
								node.material.uniforms.breathing.value  = effectController.breathing ;
							}

						}
					}

				});

			};


      // ANIMATE FUNCTION
  		function animate() {


				// scene.traverse( function( node ) {
				//
			  //   if ( node instanceof THREE.LineSegments | node instanceof THREE.Points ) {
				//
		    //     // insert your code here, for example:
		    //     // node.material = new THREE.MeshNormalMaterial() ;
				//
				// 		node.geometry.attributes.position.needsUpdate = true;
				// 		node.geometry.verticesNeedUpdate = true;
				// 	}
				//
				// } );

				// optimize rendering = every 1/24 second
				setTimeout( function() {
				  requestAnimationFrame( animate );
				}, 1000 / 20 );

				// requestAnimationFrame( animate );
				render();

        // stats.update();


      }


			// RENDER FUNCTION
  		function render() {

				// UPDATE TIME VALUE IN UNIFORMS
  			// var time  = Date.now() * 0.01;
				var time_ = ( Date.now() - start ) * .001 ;

				scene.traverse( function( node ) {

			    if ( node instanceof THREE.LineSegments | node instanceof THREE.Points ) {

						if (node.name != "helper") {
							// console.log("--- traverse / node : ", node );
							node.material.uniforms.time.value       =  time_ ;
							node.material.uniforms.velFactor.value  = effectController.velocityFactor ;
							node.material.uniforms.scaFactor.value  = effectController.scaleFactor ;
							node.material.uniforms.breathing.value  = effectController.breathing ;
						}
					}

				});



				// scene.traverse( function( node ) {
				// 	if ( node instanceof THREE.Group ) {
		  	// 		node.rotation.x = time_ * 0.04 * effectController.rotationGroup * node.customFactor ;
				// 		node.rotation.y = time_ * 0.02 * effectController.rotationGroup * node.customFactor ;
				// 	}
				// }) ;

				renderer.render( scene, camera );


  		}





    });


  }) ;




</script>
