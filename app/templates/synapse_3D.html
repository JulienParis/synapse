

<style>


#canvas3D {
				/*color: #cccccc;*/
				font-family:Monospace;
				font-size:13px;
				text-align:center;
				margin: 0px;
				overflow: hidden;
        color: #cccccc ;
        background-color: {{ app_colors.three_background }} ;
			}
div.dg.ac {
  top : 8%
}

/*
#info {
	position: absolute;
	top: 0px; width: 100%;
	padding: 5px;
}

a {
	color: #0080ff;
}
*/


</style>


<!-- cf : http://requirejs.org/docs/start.html -->
<!-- <script type="text/javascript" src="{{ url_for('static', filename='js/require.js') }}"></script> -->


<script type="text/javascript" src="{{ url_for('static', filename='js/three.js') }}"></script>
<!-- <script type="text/javascript" src="{{ url_for('static', filename='js/threejs/loaders/OBJLoader.js') }}"></script> -->
<!-- <script type="text/javascript" src="{{ url_for('static', filename='js/threejs/loaders/STLLoader.js') }}"></script> -->
<script type="text/javascript" src="{{ url_for('static', filename='js/threejs/Detector.js') }}"></script>
<script type="text/javascript" src="{{ url_for('static', filename='js/threejs/libs/dat.gui.min.js') }}"></script>
<script type="text/javascript" src="{{ url_for('static', filename='js/threejs/libs/stats.min.js') }}"></script>
<script type="text/javascript" src="{{ url_for('static', filename='js/threejs/controls/OrbitControls.js') }}"></script>
<!-- <script type="text/javascript" src="{{ url_for('static', filename='js/threejs/controls/TrackballControls.js') }}"></script> -->



<div id="canvas3D">
</div>


<!-- vertex shader cf : https://www.clicktorelease.com/blog/vertex-displacement-noise-3d-webgl-glsl-three-js/ -->
<!-- cf too  : http://blog.2pha.com/experimenting-threejs-shaders-and-shadermaterial  -->
<!-- cf also :  https://github.com/Jam3/jam3-lesson-webgl-shader-threejs -->
<script id="vertexShader" type="x-shader/x-vertex">

  attribute vec3 position;

  uniform float time ;

  uniform mat4 projectionMatrix;
  uniform mat4 modelViewMatrix;

  void main () {
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
  }

</script>


<script type="x-shader/x-vertex" id="fragmentShader">


  void main() {

    // colour is RGBA: u, v, 0, 1
    gl_FragColor = vec4( 0., 0., 0. , 1. );

  }

</script>





<script>

  $(document).ready(function(){

    // LOAD JSON NOTICES

    // XXXX var json_notices = require( "{{ url_for('static', filename='data/JSON_notices_nested.json') }}" ); //with path

    // WORKING SOLUTION
    // $.getJSON( "{{ url_for('static', filename='data/JSON_notices_nested.json') }}", function (json) {
    //   console.log(json);
    // });


    function preload_notices(callback){
      $.getJSON( "{{ url_for('static', filename='data/JSON_notices_nested.json') }}", function( json ) {
        console.log("... JSON_notices_nested loaded with getJSON");
        callback(json);
      }
    )};

    preload_notices(function(json) {
      //Use your data here
      console.log("... JSON_notices_nested after callback");
      var json_notices = json ;
      console.log( json_notices );


      var start = Date.now() ;

      var group;
  		var container, controls, stats ;
  		var particlesData = [] ;
  		var camera, scene, renderer ;
      var raycaster, mouse;


  		var positions, colors ;
  		var particles  ;
  		var pointCloud ;
  		var particlePositions ;
  		var linesMesh ;


  		var maxParticleCount = 3000;
  		var particleCount = 300;
  		var r = 800;
  		var rHalf = r / 2;

      var velocityFactor = 1.1 ;

  		var effectController = {
  			showDots: true,
  			showLines: true,
  			minDistance: 120,
  			limitConnections: true,
  			maxConnections: 10,
  			particleCount: particleCount,
        velocityFactor: 1
  		};



      // custom particles material vertex shader
      var materialPoints_shader = new THREE.RawShaderMaterial( {


        uniforms: {
          color: { type: "c", value: new THREE.Color( 0xffffff ) },
          size : { type: "f", value: []  },
          time : { type: "f", value: 0.0 }
        },

        vertexShader   : document.getElementById( 'vertexShader' ).textContent,
        fragmentShader : document.getElementById( 'fragmentShader' ).textContent

      } );


      var materialPoints = new THREE.PointsMaterial( {
        color: 0xFFFFFF,
        size: 3,
        blending: THREE.AdditiveBlending,
        transparent: true,
        sizeAttenuation: false
      } );


  		init();
  		animate();

      function initGUI() {
  			var gui = new dat.GUI();
  			gui.add( effectController, "showDots" ).onChange( function( value ) { pointCloud.visible = value; } );
  			gui.add( effectController, "showLines" ).onChange( function( value ) { linesMesh.visible = value; } );
  			gui.add( effectController, "minDistance", 10, 300 );
        gui.add( effectController, "velocityFactor", 0, 10 );
  			gui.add( effectController, "limitConnections" );
  			gui.add( effectController, "maxConnections", 0, 30, 1 );
  			gui.add( effectController, "particleCount", 0, maxParticleCount, 1 ).onChange( function( value ) {
  				particleCount = parseInt( value );
  				particles.setDrawRange( 0, particleCount );
  			});
  		}

      function init() {

      	initGUI();
  			container = document.getElementById( 'canvas3D' );

      	// set scene
  			camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 4000 );
  			camera.position.z = 1750;
  			scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2( 0xcccccc, 0.002 );







        group = new THREE.Group();
  			scene.add( group );

        // var helper = new THREE.BoxHelper( new THREE.Mesh( new THREE.BoxGeometry( r, r, r ) ) );
  			// helper.material.color.setHex( 0x080808 );
  			// helper.material.blending = THREE.AdditiveBlending;
  			// helper.material.transparent = true;
  			// group.add( helper );

        var segments = maxParticleCount * maxParticleCount;
  			positions = new Float32Array( segments * 3 );
  			colors = new Float32Array( segments * 3 );







        particles = new THREE.BufferGeometry();
  			particlePositions = new Float32Array( maxParticleCount * 3 );
  			for ( var i = 0; i < maxParticleCount; i++ ) {
  				var x = Math.random() * r - r / 2;
  				var y = Math.random() * r - r / 2;
  				var z = Math.random() * r - r / 2;
  				particlePositions[ i * 3     ] = x;
  				particlePositions[ i * 3 + 1 ] = y;
  				particlePositions[ i * 3 + 2 ] = z;
  				// add it to the geometry
  				particlesData.push( {
  					velocity: new THREE.Vector3( -1 + Math.random() , -1 + Math.random(),  -1 + Math.random() ),
  					numConnections: 0
  				} );
  			}
  			particles.setDrawRange( 0, particleCount );
  			particles.addAttribute( 'position', new THREE.BufferAttribute( particlePositions, 3 ).setDynamic( true ) );

        // create the particle system with material
  			pointCloud = new THREE.Points( particles, materialPoints );
  			group.add( pointCloud );


        var geometry = new THREE.BufferGeometry();
  			geometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ).setDynamic( true ) );
  			geometry.addAttribute( 'color'   , new THREE.BufferAttribute( colors, 3 ).setDynamic( true ) );
  			geometry.computeBoundingSphere();
  			geometry.setDrawRange( 0, 0 );


        var materialLines = new THREE.LineBasicMaterial( {
  				vertexColors: THREE.VertexColors,
  				blending    : THREE.AdditiveBlending,
  				transparent : true
  			} );
  			linesMesh = new THREE.LineSegments( geometry, materialLines );
  			group.add( linesMesh );

        //
  			renderer = new THREE.WebGLRenderer( { antialias: true, alpha : true } ); // alpha true for css background-color
  			renderer.setPixelRatio( window.devicePixelRatio );
  			renderer.setSize( window.innerWidth, window.innerHeight );
  			renderer.gammaInput = true;
  			renderer.gammaOutput = true;
  			container.appendChild( renderer.domElement );


        controls = new THREE.OrbitControls( camera, container );

        // controls = new THREE.TrackballControls( camera, renderer.domElement );
  			controls.minDistance = 100.0;
  			controls.maxDistance = 3000.0;
  			controls.dampingFactor = 0.1;

        // set stats box
  			// stats = new Stats();
  			// container.appendChild( stats.dom );


        // raycasting for mouse interaction
				raycaster = new THREE.Raycaster();
				mouse     = new THREE.Vector2();

        window.addEventListener(   'resize',    onWindowResize, false );
        document.addEventListener( 'mousemove', onDocumentMouseMove, false );

      }

      function onDocumentMouseMove( event ) {
      				event.preventDefault();
      				mouse.x =   ( event.clientX / window.innerWidth )  * 2 - 1;
      				mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
      			}

      function onWindowResize() {
  			camera.aspect = window.innerWidth / window.innerHeight;
  			camera.updateProjectionMatrix();
  			renderer.setSize( window.innerWidth, window.innerHeight );
  		}

      //
  		function animate() {

        var vertexpos = 0;
  			var colorpos = 0;
  			var numConnected = 0;

        for ( var i = 0; i < particleCount; i++ )
  				particlesData[ i ].numConnections = 0;

        for ( var i = 0; i < particleCount; i++ ) {

          // get the particle
  				var particleData = particlesData[i];
  				particlePositions[ i * 3     ] += particleData.velocity.x * effectController.velocityFactor ;
  				particlePositions[ i * 3 + 1 ] += particleData.velocity.y * effectController.velocityFactor ;
  				particlePositions[ i * 3 + 2 ] += particleData.velocity.z * effectController.velocityFactor ;

          if ( particlePositions[ i * 3 + 1 ] < -rHalf || particlePositions[ i * 3 + 1 ] > rHalf )
  					particleData.velocity.y = -particleData.velocity.y;
  				if ( particlePositions[ i * 3 ] < -rHalf || particlePositions[ i * 3 ] > rHalf )
  					particleData.velocity.x = -particleData.velocity.x;
  				if ( particlePositions[ i * 3 + 2 ] < -rHalf || particlePositions[ i * 3 + 2 ] > rHalf )
  					particleData.velocity.z = -particleData.velocity.z;
  				if ( effectController.limitConnections && particleData.numConnections >= effectController.maxConnections )
  					continue;

          // Check collision
  				for ( var j = i + 1; j < particleCount; j++ ) {
  					var particleDataB = particlesData[ j ];
  					if ( effectController.limitConnections && particleDataB.numConnections >= effectController.maxConnections )
  						continue;
  					var dx = particlePositions[ i * 3     ] - particlePositions[ j * 3     ];
  					var dy = particlePositions[ i * 3 + 1 ] - particlePositions[ j * 3 + 1 ];
  					var dz = particlePositions[ i * 3 + 2 ] - particlePositions[ j * 3 + 2 ];
  					var dist = Math.sqrt( dx * dx + dy * dy + dz * dz );
  					if ( dist < effectController.minDistance ) {
  						particleData.numConnections++;
  						particleDataB.numConnections++;
  						var alpha = 1.0 - dist / effectController.minDistance;
  						positions[ vertexpos++ ] = particlePositions[ i * 3     ];
  						positions[ vertexpos++ ] = particlePositions[ i * 3 + 1 ];
  						positions[ vertexpos++ ] = particlePositions[ i * 3 + 2 ];
  						positions[ vertexpos++ ] = particlePositions[ j * 3     ];
  						positions[ vertexpos++ ] = particlePositions[ j * 3 + 1 ];
  						positions[ vertexpos++ ] = particlePositions[ j * 3 + 2 ];
  						colors[ colorpos++ ] = alpha;
  						colors[ colorpos++ ] = alpha;
  						colors[ colorpos++ ] = alpha;
  						colors[ colorpos++ ] = alpha;
  						colors[ colorpos++ ] = alpha;
  						colors[ colorpos++ ] = alpha;
  						numConnected++;
  					}
  				}
  			}

        linesMesh.geometry.setDrawRange( 0, numConnected * 2 );
  			linesMesh.geometry.attributes.position.needsUpdate = true;
  			linesMesh.geometry.attributes.color.needsUpdate = true;
  			pointCloud.geometry.attributes.position.needsUpdate = true;
  			requestAnimationFrame( animate );

        // stats.update();
  			render();

      }


  		function render() {

  			var time = Date.now() * 0.001;

        materialPoints_shader.uniforms.time.value = 0.001 * ( Date.now() - start );


				raycaster.setFromCamera( mouse, camera );
				var intersects = raycaster.intersectObject( group );
        if ( intersects.length > 0 ) {
          console.log( "-X- intersecting");
        } else {

        }


  			// group.rotation.y = time * 0.1;
  			renderer.render( scene, camera );

  		}






    });


  }) ;




</script>
